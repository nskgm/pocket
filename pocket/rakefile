#---------------------------------------------------------------------
# config
#---------------------------------------------------------------------

# 出力実行ファイル名
EXECUTE_FILE = "main.exe"
# 実行ファイル引数
# 文字列はダブルコーテーションは外して渡される
# ダブルコーテーションをつけるときは "\\\"NAME\\\""
EXECUTE_ARGS = [
	"Hello",
	"World",
	1,
	2
]
# C++バージョン
# 指定しない場合は0
CXX_VER = 11
# ライブラリディレクトリ
INC_DIRS = [
	# 文字列配列
	"inc/gl"
]
LIB_DIRS = [
	# 文字列配列
	"lib"
]
# 事前に定義
DEFINES = [
	# 文字列配列
	"POCKET_HELLO",
	"POCKET_WORLD"
]
# 事前定義に対しての値を設定
# 文字列で渡した場合は文字列で定義される
DEFINE_VALUES = {
	# 文字列に対して値
	"POCKET_HELLO_STR" => "Hello",
	"POCKET_WORLD_STR" => "World",
	"POCKET_VERSION_MAJOR" => 1
}
# 事前にて定義を無効
UNDEFINES = [
	# 文字列配列
]
# デバッグを有効にするか
DEBUG = true
# 警告を有効にするか
WARNING = true

#---------------------------------------------------------------------
# implementatioin
#---------------------------------------------------------------------
require "rake/clean"
# 中間ファイルディレクトリ
OBJ_DIR = "obj"
DEP_DIR = OBJ_DIR+"/dep" # dependencies
# 削除対象ファイルorディレクトリ
# [EXECUTE_FILE, "**/*.o", "**/*.d", OBJ_DIR]
CLEAN_LIST = [EXECUTE_FILE, OBJ_DIR]
CLEAN.include CLEAN_LIST
CLOBBER.include CLEAN_LIST

# 配列から連結文字列を作成
def array_to_join_string(a, sep=" ")
	tmp = a.map do |e| yield e end if a.length > 0
	tmp.join sep if tmp != nil
end
# ハッシュから連結文字列を作成
def hash_to_join_string(a, sep=" ")
	tmp = a.map do |k, v| yield k, v end if a.length > 0
	tmp.join sep if tmp != nil
end
def to_pre_compile_option(a)
	# 文字列じゃない場合はそのまま
	return a unless a.kind_of? String
	"\\\"#{a}\\\""
end

#--------------------
# デフォルトタスク
#--------------------
desc "default: build_and_run"
task :default => [:build_and_run]

#--------------------
# 実行ファイルを作成
#--------------------
desc "build #{EXECUTE_FILE}"
task :build => [OBJ_DIR, DEP_DIR, :pre_build, EXECUTE_FILE, :post_build]

#--------------------
# 実行ファイルを作成し直す
#--------------------
desc "rebuild #{EXECUTE_FILE}"
task :rebuild => [:clean, :build]

#--------------------
# 実行ファイルを実行
#--------------------
desc "execute #{EXECUTE_FILE}"
task :run do |t|
	command = "#{EXECUTE_FILE}"

	# 実行ファイルの引数の連結
	args = array_to_join_string EXECUTE_ARGS do |e| e end
	command += " #{args}" if args != nil
	sh command
end

#--------------------
# 実行ファイルを作成して実行
#--------------------
desc "build and run: #{EXECUTE_FILE}"
task :build_and_run => [:build, :run]

#--------------------
# 実行ファイルを作成し直して実行
#--------------------
desc "rebuild and run: #{EXECUTE_FILE}"
task :rebuild_and_run => [:rebuild, :run]

#--------------------
# 中間ファイル用ディレクトリ作成
#--------------------
directory OBJ_DIR

#--------------------
# ファイル依存関係ファイルディレクトリ作成
#--------------------
directory DEP_DIR => OBJ_DIR

# 拡張子を変更
def replace_ext(path, ext)
	path.gsub File.extname(path), ext
end
# ファイル名をディレクトリ＋ファイル名の形で作成
def filepath(dir, path, suffix="")
	# / or \ を - に置き換えてパスを作成
	def replace(d, a, r, s)
		"#{d}/#{File.dirname(a).gsub(r, "-")}-#{File.basename(a, s)}"
	end

	# ディレクトリが含まれている場合は文字列置換
	return replace(dir, path, "/", suffix) if path.index("/") != nil
	return replace(dir, path, "\\", suffix) if path.index("\\") != nil
	# 含まれない場合
	"#{dir}/#{File.basename(path, suffix)}"
end

# 依存ファイル出力ディレクトリ
def dep_filepath(s)
	#return replace_ext s, ".d" if PLACEMENT
	"#{filepath(DEP_DIR, s, ".*")}.d"
end
# 中間ファイル出力ディレクトリ
def obj_filepath(s)
	#return replace_ext s, ".o" if PLACEMENT
	"#{filepath(OBJ_DIR, s, ".*")}.o"
end

# 対象コンパイラ
COMPILER = "g++"
# コンパイル対象拡張子
EXT_LIST = [".c", ".cpp", ".cxx"]
# 拡張子に対するファイルの列挙
SOURCE_LIST = FileList[EXT_LIST.map do |e| "**/*#{e}" end]
# 中間ファイル
OBJ_LIST = SOURCE_LIST.map do |e| obj_filepath e end
# 依存関係ファイル
DEP_LIST = SOURCE_LIST.map do |e| dep_filepath e end
# リリースを有効にするか
RELEASE = !DEBUG

# 経過時間の計測
start_time = nil

#--------------------
# ビルド前処理（実装）
#--------------------
task :pre_build do |t|
	# 開始時間取得
	start_time = Time.now

	# 事前に定義する配列
	defines = array_to_join_string DEFINES do |e| "-D\"#{e}\"" end
	define_values = hash_to_join_string DEFINE_VALUES do |k, v| "-D\"#{k}=#{to_pre_compile_option v}\"" end
	undefines = array_to_join_string UNDEFINES do |e| "-U\"#{e}\"" end
	# ライブラリ文字列の連結
	inc = array_to_join_string INC_DIRS do |e| "-I\"#{e}\"" end
	lib = array_to_join_string LIB_DIRS do |e| "-L\"#{e}\"" end

	# ファイルタスクを生成
	for i in 0...SOURCE_LIST.length
		src_file = SOURCE_LIST[i] # ソースファイル
		obj_file = OBJ_LIST[i] # 中間ファイル
		dep_file = DEP_LIST[i] # 依存関係ファイル

		# ソースが変更されていたら依存関係ファイルを更新する
		file dep_file => src_file do |t|
			# -MM システムinclude以外の依存include
			# -MT 中間ファイルターゲット名
			# -MF 出力ファイルパス
			sh "#{COMPILER} -MM -MT #{obj_file} -MF #{t.name} #{t.source}"
		end
		file(dep_file).invoke

		# 依存関係ファイルを書き込んだら読み込んで依存のファイルを読み込む
		# ファイル全体取得
		all = File.read dep_file
		# 邪魔な文字を削除
		["\\", "\n"].each do |s| all.delete! s end
		# 空白で分割
		headers = all.split ' '
		# 中間ファイル名とソースファイル名をスキップ
		2.times do headers.shift end

		# ソースと依存しているヘッダを見て中間ファイルを作成
		file obj_file => [src_file, headers].flatten do |t|
			# 実行するシェルコマンド
			command = "#{COMPILER} -c #{t.source} -o #{t.name}"
			command += " -std=c++#{CXX_VER == 03 ? "03" : CXX_VER}" if CXX_VER > 0 # CXX_VER
			command += " -Wall -Wextra -Wcast-qual" if WARNING # 警告
			command += " -w" unless WARNING # 警告をすべて無効
			command += " -g" if DEBUG # デバッグ情報をつける
			command += " -O2 -march=native" if RELEASE # 最高の最適化＋コンパイルマシン最適化
			command += " #{inc}" if inc != nil # システムinclude
			command += " #{lib}" if lib != nil # システムlibrary
			command += " #{defines}" if defines != nil # 事前定義
			command += " #{define_values}" if define_values != nil # 事前定義+値
			command += " #{undefines}" if undefines != nil # 事前定義無効
			# シェル実行
			sh command
		end
		file(obj_file).invoke
	end
end

#--------------------
# ビルド後処理
#--------------------
task :post_build do
	line = "#{"-"*50}\n"
	print line
	print "compile time: #{Time.now - start_time}s\n"
	print line
end

#--------------------
# 実行ファイル作成
#--------------------
file EXECUTE_FILE => OBJ_LIST do |t|
	# 中間ファイル名リスト
	#obj_list = t.prerequisites.map do |n| obj_filepath n end
	command = "#{COMPILER} -o #{EXECUTE_FILE} #{t.prerequisites.join(" ")}"
	sh command
end

task :test do
	FileUtils.touch FileList["**/*.h"]
	task(:build).invoke
end
